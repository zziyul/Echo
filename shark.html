<!DOCTYPE html>
<html>
    <head>
        <title>TODO supply a title</title>
        <meta charset="UTF-8">
        <style>
            @import url(http://fonts.googleapis.com/earlyaccess/hanna.css);
            *{

                font-family: 'Hanna', serif;

            }
            button{
                background-color : #395687;
                font-size : 20px;
                border-radius : 10px;
                width : 200px;
                height: 50px;
                border : 0;
                color : #F1F1F1;
                display : block;
                margin-bottom : 10px;
                float: left;
                margin-right: 20px;
            }
        </style>
    </head>
    <body onload="main()" style="background-color : #E8C720; padding-bottom: 0;"> 
        <div id ="content" style = "overflow : hidden; background-color : #427590; width : 1800px; height : 900px; padding-top : 20px; padding-bottom : 70px; border-radius : 100px; margin-left: 3%; margin-top:50px;">
            <div style='border: 50px solid orange;  background-color : orange; margin : auto 0; margin : 20px 200px; margin-left : 18%;  width:1000px; height : 800px;'>
                <canvas id="myCanvas" width=1000; height=700;></canvas>
                <video id="myVideo" controls="true" src="shark.mp4" autoplay="true" style = "position : fixed; top : 700px; left : 439px;"></video>
                <div style='margin-top: 20px; margin-left: 190px;' width=1000 >
                    <button onclick="neonOnOff()">네온효과 on/off</button>
                    <button onclick="moveOnOff()">움직임효과 on/off</button>
                    <button onclick="mirrorOnOff()">좌우효과 on/off</button>
                </div>
                <p style=" text-align: center; "><input type=file><div id="holder"></div></p>

            </div>
            <img src="back.png" style="width:100px; height: 100px; float: right; margin-right: 7%; position:fixed; top : 900px; right : 20px;;" onclick="history.back();">

        </div>

        <script src="webgl-utils.js"></script>
        <script src="webgl-debug.js"></script>
        <script src="cuon-utils.js"></script>
        <script src="cuon-matrix.js"></script>
        <script>
                var VSHADER_SOURCE =
                        'attribute vec4 a_Position; \n' +
                        'attribute vec4 a_Color; \n' +
                        'attribute vec2 a_TexCoord; \n' +
                        'varying vec4 outColor; \n' +
                        'varying vec2 v_TexCoord; \n' +
                        'void main() { \n' +
                        '  gl_Position = a_Position; \n' +
                        '  outColor = a_Color; \n' +
                        '  outColor.a = 1.0;\n' +
                        '  v_TexCoord = a_TexCoord; \n' +
                        '}\n';

                var FSHADER_SOURCE =
                        'precision mediump float; \n' +
                        'uniform sampler2D u_texture; \n' +
                        'varying vec4 outColor; \n' +
                        'varying vec2 v_TexCoord; \n' +
                        'uniform float u_Alpha;\n' +
                        'void main() { \n' +
                        '   gl_FragColor = texture2D(u_texture, v_TexCoord)*outColor; \n' +
                        '}\n';

                var vertices = [
                    //백그라운드
                    -1.0, -1.0, 0.11, 1.0, 1.0, 1.0, 0.0, 0.0,
                    1.0, -1.0, 0.11, 1.0, 1.0, 1.0, 1.0, 0.0,
                    -1.0, 1.0, 0.11, 1.0, 1.0, 1.0, 0.0, 1.0,
                    1.0, 1.0, 0.11, 1.0, 1.0, 1.0, 1.0, 1.0,

                    //객체0
                    -1.0, -0.2, 0.1, 1.0, 1.0, 1.0, 0.0, 0.0,
                    -0.6, -0.2, 0.1, 1.0, 1.0, 1.0, 1.0, 0.0,
                    -1.0, 0.2, 0.1, 1.0, 1.0, 1.0, 0.0, 1.0,
                    -0.6, 0.2, 0.1, 1.0, 1.0, 1.0, 1.0, 1.0,
                    //객체1
                    -0.6, -0.2, 0.09, 1.0, 1.0, 1.0, 0.0, 0.0,
                    -0.2, -0.2, 0.09, 1.0, 1.0, 1.0, 1.0, 0.0,
                    -0.6, 0.2, 0.09, 1.0, 1.0, 1.0, 0.0, 1.0,
                    -0.2, 0.2, 0.09, 1.0, 1.0, 1.0, 1.0, 1.0,

                    //객체2
                    -0.2, -0.2, 0.1, 1.0, 1.0, 1.0, 0.0, 0.0,
                    0.2, -0.2, 0.1, 1.0, 1.0, 1.0, 1.0, 0.0,
                    -0.2, 0.2, 0.1, 1.0, 1.0, 1.0, 0.0, 1.0,
                    0.2, 0.2, 0.1, 1.0, 1.0, 1.0, 1.0, 1.0,

                    //객체3
                    0.2, -0.2, 0.1, 1.0, 1.0, 1.0, 0.0, 0.0,
                    0.6, -0.2, 0.1, 1.0, 1.0, 1.0, 1.0, 0.0,
                    0.2, 0.2, 0.1, 1.0, 1.0, 1.0, 0.0, 1.0,
                    0.6, 0.2, 0.1, 1.0, 1.0, 1.0, 1.0, 1.0,

                    //객체4
                    0.6, -0.2, 0.1, 1.0, 1.0, 1.0, 0.0, 0.0,
                    1.0, -0.2, 0.1, 1.0, 1.0, 1.0, 1.0, 0.0,
                    0.6, 0.2, 0.1, 1.0, 1.0, 1.0, 0.0, 1.0,
                    1.0, 0.2, 0.1, 1.0, 1.0, 1.0, 1.0, 1.0,
                ];

                var indices = [
                    0, 1, 2, 2, 1, 3,
                    4, 5, 6, 6, 5, 7,
                    8, 9, 10, 10, 9, 11,
                    12, 13, 14, 14, 13, 15,
                    16, 17, 18, 18, 17, 19,
                    20, 21, 22, 22, 21, 23,
                    24, 25, 26, 26, 25, 27,
                    28, 29, 30, 30, 29, 31,
                    32, 33, 34, 34, 33, 35,
                    36, 37, 38, 38, 37, 39,
                    40, 41, 42, 42, 41, 43
                ];


                var cv;
                var gl;
                var posLoc;
                var colLoc;
                var cubeVBO;
                var cubeVEO;
                var doneOnload;// 텍스처 로드가 됐는지 확인하는 변수
                var neon = false; // 나비들에게 네온 효과를 줄것인지
                var move = false; // 나비들에게 움직임 효과를 줄것인지
                var mirror = false; // 나비들에게 미러 효과를 줄것인지
                var mirrorTiming = 0;

                var loadImg = 'sea.jpg'; // 로드된 이미지를 출력한다.


                var upload = document.getElementsByTagName('input')[0],
                        holder = document.getElementById('holder'),
                        state = document.getElementById('status');

                upload.onchange = function (e) {
                    e.preventDefault();

                    var file = upload.files[0];
                    var reader = new FileReader();
                    reader.onload = function (event) {
                        var img = new Image();
                        img.src = event.target.result;
                        // note: no onload required since we've got the dataurl...I think! :)
                        img.heigth = 256;
                        img.width = 256;
                        holder.innerHTML = '';


                        // holder.appendChild(img);

                        console.log(img);
                        loadImg = img.src;
                        //loadImge = makeSuitableForTexture(loadImg);
                        //console.log(loadImge);

                        // 크기가 2^n * 2^n인 파일만 가능
                        //수정사항 크기가 2^n * 2^n이 아닌 파일을 업로드 하더라고 width, height문제를 해결하고 업로드 되야한다.
                    };
                    reader.readAsDataURL(file);

                    return false;
                };

                var texImage = [];//텍스처 이미지를 저장하는 배열
                function main() {
                    cv = document.getElementById('myCanvas');
                    gl = cv.getContext('webgl');

                    //gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
                    initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE);
                    posLoc = gl.getAttribLocation(gl.program, 'a_Position'); // 속성가져오기 - 위치
                    colLoc = gl.getAttribLocation(gl.program, 'a_Color'); // 속성가져오기 - 색상

                    gl.enableVertexAttribArray(posLoc);
                    gl.enableVertexAttribArray(colLoc);

                    init();
                    startMove();
                }

                function init() {
                    // gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                    cubeVBO = gl.createBuffer();
                    cubeVEO = gl.createBuffer();
                    posLoc = gl.getAttribLocation(gl.program, 'a_Position');
                    colLoc = gl.getAttribLocation(gl.program, 'a_Color');
                    texLoc = gl.getAttribLocation(gl.program, 'a_TexCoord');

                    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVBO);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
                    gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 4 * 8, 0);
                    gl.vertexAttribPointer(colLoc, 3, gl.FLOAT, false, 4 * 8, 4 * 3);
                    gl.vertexAttribPointer(texLoc, 2, gl.FLOAT, false, 4 * 8, 4 * 6);
                    gl.enableVertexAttribArray(posLoc);
                    gl.enableVertexAttribArray(colLoc);
                    gl.enableVertexAttribArray(texLoc);

                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVEO);
                    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(indices), gl.STATIC_DRAW);
                }
                function draw() {
                    init();


                    //배경을 그린다.
                    texImage[0] = new Image();
                    texImage[0].onload = function () {
                        gl.texID = gl.createTexture();
                        //texID[j] = gl.texID;
                        gl.activeTexture(gl.TEXTURE0);
                        //                console.log(0);
                        //                console.log(texImage[0]);
                        gl.bindTexture(gl.TEXTURE_2D, gl.texID);

                        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, texImage[0]);

                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

                        // 그리기n 이미지가 로드되야 그린다.
                        var samplerLoc = gl.getUniformLocation(gl.program, 'u_texture');
                        gl.uniform1i(samplerLoc, 0);

                        gl.enable(gl.BLEND);
                        gl.blendFunc(gl.SRC_COLOR, gl.ONE_MINUS_SRC_COLOR);
                        // gl.disable(gl.DEPTH_TEST);
                        //gl.uniform1f(uAlpha, 1.0);
                        gl.enable(gl.DEPTH_TEST);
                        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_BYTE, 6 * 0);
                    };
                    texImage[0].src = loadImg; // 배경을 먼저 그려준다.


                    draw1();
                    draw2();
                    draw3();
                    draw4();
                    draw5();

                }
                function draw1() {
                    var i = 1;
                    //나비를 그린다.
                    texImage[i] = new Image();
                    texImage[i].onload = function () {
                        gl.texID = gl.createTexture();
                        //texID[j] = gl.texID;
                        gl.activeTexture(gl.TEXTURE0);
                        //console.log(1);
                        //console.log(texImage[1]);
                        gl.bindTexture(gl.TEXTURE_2D, gl.texID);

                        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, texImage[i]);

                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

                        // 그리기 이미지가 로드되야 그린다.
                        var samplerLoc = gl.getUniformLocation(gl.program, 'u_texture');
                        gl.uniform1i(samplerLoc, 0);


                        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_BYTE, 6 * i);
                    };
                    if (mirror) {
                        if ((Math.random() * 100) > 50 && mirrorTiming > 50)
                            texImage[i].src = 'shark0_m.png'; // 나비 그려주기
                        else
                            texImage[i].src = 'shark0.png'; // 나비 그려주기
                    } else {
                        texImage[i].src = 'shark0.png'; // 나비 그려주기
                    }

                }
                function draw2() {
                    var i = 2;
                    texImage[i] = new Image();
                    texImage[i].onload = function () {
                        gl.texID = gl.createTexture();
                        //texID[j] = gl.texID;
                        gl.activeTexture(gl.TEXTURE0);
                        //console.log(1);
                        //console.log(texImage[1]);
                        gl.bindTexture(gl.TEXTURE_2D, gl.texID);

                        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, texImage[i]);

                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

                        // 그리기 이미지가 로드되야 그린다.
                        var samplerLoc = gl.getUniformLocation(gl.program, 'u_texture');
                        gl.uniform1i(samplerLoc, 0);

                        gl.enable(gl.DEPTH_TEST);
                        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_BYTE, 6 * i);
                    };
                    if (mirror) {
                        if ((Math.random() * 100) > 50 && mirrorTiming > 50)
                            texImage[i].src = 'shark1_m.png'; // 나비 그려주기
                        else
                            texImage[i].src = 'shark1.png'; // 나비 그려주기
                    } else {
                        texImage[i].src = 'shark1.png'; // 나비 그려주기
                    }
                }
                function draw3() {
                    var i = 3;
                    texImage[i] = new Image();
                    texImage[i].onload = function () {
                        gl.texID = gl.createTexture();
                        //texID[j] = gl.texID;
                        gl.activeTexture(gl.TEXTURE0);
                        //console.log(1);
                        //console.log(texImage[1]);
                        gl.bindTexture(gl.TEXTURE_2D, gl.texID);

                        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, texImage[i]);

                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

                        // 그리기 이미지가 로드되야 그린다.
                        var samplerLoc = gl.getUniformLocation(gl.program, 'u_texture');
                        gl.uniform1i(samplerLoc, 0);

                        gl.enable(gl.DEPTH_TEST);
                        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_BYTE, 6 * i);
                    };
                    if (mirror) {
                        if ((Math.random() * 100) > 50 && mirrorTiming > 50)
                            texImage[i].src = 'shark2_m.png'; // 나비 그려주기
                        else
                            texImage[i].src = 'shark2.png'; // 나비 그려주기
                    } else {
                        texImage[i].src = 'shark2.png'; // 나비 그려주기
                    }
                }
                function draw4() {
                    var i = 4;
                    texImage[i] = new Image();
                    texImage[i].onload = function () {
                        gl.texID = gl.createTexture();
                        //texID[j] = gl.texID;
                        gl.activeTexture(gl.TEXTURE0);
                        //console.log(1);
                        //console.log(texImage[1]);
                        gl.bindTexture(gl.TEXTURE_2D, gl.texID);

                        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, texImage[i]);

                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

                        // 그리기 이미지가 로드되야 그린다.
                        var samplerLoc = gl.getUniformLocation(gl.program, 'u_texture');
                        gl.uniform1i(samplerLoc, 0);

                        gl.enable(gl.DEPTH_TEST);
                        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_BYTE, 6 * i);
                    };
                    if (mirror) {
                        if ((Math.random() * 100) > 50 && mirrorTiming > 50)
                            texImage[i].src = 'shark3_m.png'; // 나비 그려주기
                        else
                            texImage[i].src = 'shark3.png'; // 나비 그려주기
                    } else {
                        texImage[i].src = 'shark3.png'; // 나비 그려주기
                    }
                }
                function draw5() {
                    var i = 5;
                    texImage[i] = new Image();
                    texImage[i].onload = function () {
                        gl.texID = gl.createTexture();
                        //texID[j] = gl.texID;
                        gl.activeTexture(gl.TEXTURE0);
                        //console.log(1);
                        //console.log(texImage[1]);
                        gl.bindTexture(gl.TEXTURE_2D, gl.texID);

                        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, texImage[i]);

                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

                        // 그리기 이미지가 로드되야 그린다.
                        var samplerLoc = gl.getUniformLocation(gl.program, 'u_texture');
                        gl.uniform1i(samplerLoc, 0);

                        gl.enable(gl.DEPTH_TEST);
                        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_BYTE, 6 * i);
                    };
                    if (mirror) {
                        if ((Math.random() * 100) > 50 && mirrorTiming > 50)
                            texImage[i].src = 'shark4_m.png'; // 나비 그려주기
                        else
                            texImage[i].src = 'shark4.png'; // 나비 그려주기
                    } else {
                        texImage[i].src = 'shark4.png'; // 나비 그려주기
                    }
                }

        </script>


        <script>
            var c = 0;
            var audioContext = new AudioContext();
            var ctx = new AudioContext();
            var audio = document.getElementById('myVideo');

            var audioSrc = ctx.createMediaElementSource(audio);
            var analyser = ctx.createAnalyser();
            // we have to connect the MediaElementSource with the analyser 
            audioSrc.connect(analyser);
            audioSrc.connect(ctx.destination); // 스피커로 노래가 출력되게 하기
            // we could configure the analyser: e.g. analyser.fftSize (for further infos read the spec)

            // frequencyBinCount tells you how many values you'll receive from the analyser
            var frequencyData = new Uint8Array(analyser.frequencyBinCount);

            // we're ready to receive some data!
            // loop


            var neontiming = 0;
            var movetiming = 0;


            function startMove() {
                var renderFrame = function () {
                    requestAnimationFrame(renderFrame);
                    // update data in frequencyData
                    analyser.getByteFrequencyData(frequencyData);
                    // render frame based on values in frequencyData

                    //다섯 구간으로 나워서 평균을 구한다.
                    var sum = [];

                    for (var i = 0; i < 200; i += 40) {
                        sum[i / 40] = 0;
                        for (var j = i; j < i + 40; j++) {
                            sum[i / 40] += frequencyData[j];
                        }
                    }

                    for (var i = 0; i < 5; i++) {
                        var temp = vertices[33 + i * 32];

                        vertices[33 + i * 32] = sum[i] / 6000 - 0.8;
                        //sum[i] = 0;
                        // console.log(sum / 1024);
                        var distanceY = temp - vertices[33 + i * 32];// y이동거리를 구한다.

                        //x,y이동거리만큼 움직여준다.
                        vertices[41 + i * 32] -= distanceY;
                        vertices[49 + i * 32] -= distanceY;
                        vertices[57 + i * 32] -= distanceY;


                        if (neon) {
                            neontiming++;
                            if (neontiming % 10 == 0) {
                                neontiming = 0;
                                for (var j = 0; j < 5; j++)
                                    for (var k = 0; k < 3; k++) {

                                        // console.log(Math.random() > 50);
                                        vertices[35 + k + j * 32] = Math.random() + 0.51;
                                        vertices[43 + k + j * 32] = Math.random() + 0.51;
                                        vertices[51 + k + j * 32] = Math.random() + 0.51;
                                        vertices[59 + k + j * 32] = Math.random() + 0.51;

                                    }
                            }
                        }

                        if (move) {
                            movetiming++;
                            if (movetiming % 10 == 0) {
                                movetiming = 0;
                                for (var j = 0; j < 5; j++) {
                                    var moveDis = (0.5 - Math.random()) / 100;
                                    vertices[32 + j * 32] -= moveDis;
                                    vertices[40 + j * 32] -= moveDis;
                                    vertices[48 + j * 32] -= moveDis;
                                    vertices[56 + j * 32] -= moveDis;
                                }

                            }
                        }
                        mirrorTiming++;
                        if (mirrorTiming > 100) {
                            mirrorTiming = 0;
                        }
                        //console.log(vertices);
                    }
                    draw();
                }
                //audio.play();
                renderFrame();
            }

            function neonOnOff() {
                if (neon) {
                    neon = false;
                } else {
                    neon = true;
                }
            }

            function moveOnOff() {
                if (move) {
                    move = false;
                } else {
                    move = true;
                }
            }

            function mirrorOnOff() {
                if (mirror) {
                    mirror = false;
                } else {
                    mirror = true;
                }
            }
        </script>

    </body>
</html>